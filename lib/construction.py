# %%
import numpy as np
from numpy.random import default_rng
import galois
# import stim
from .utils import solvesystem

GF = galois.GF(2)

# %%
def wrap_seed(seed):
    '''
    Convert seed into a np.random.Generator
    '''
    if seed is None or type(seed) == int:
        rng = default_rng(seed)
    elif type(seed) == np.random.Generator:
        rng = seed
    else:
        raise ValueError("Seed must be an integer, a numpy.random.Generator or None.")
    return rng


def random_main_part(n, g, s, seed = None):
    '''
    Randomly sample g rows that have inner products one with the secret s. 
    Args:
        n (int): number of qubits
        g (int): number of rows
        s (galois.FieldArray): secret vector
        seed (int | np.random.Generator): seed for random sampling
    Return:
        A random main part with g rows.
    '''
    assert len(s) == n, "Inconsistent shapes"
    H = []
    rng = wrap_seed(seed)
    while len(H) < g:
        # seed = int(rng.random() * 10**5)
        row = GF.Random(n, seed = rng)
        if np.dot(row, s) == 1:
            H.append(row)
    H = GF(H)
    return H

def random_gram(n, g, s, seed = None):
    '''
    Generate a random Gram matrix with rank <= g. It is generated by first sampling g rows that are not orthogonal to s, to form H. Then, G = H^T \cdot H
    Args:
        n (int): number of qubits
        g (int): number of rows
        s (galois.FieldArray): secret vector
        seed (int | np.random.Generator): seed for random sampling
    Return:
        A random Gram matrix generated by G = H^T \cdot H
    '''
    rng = wrap_seed(seed)
    H = random_main_part(n, g, s, seed = rng)
    G = H.T @ H
    return G


def random_tableau(n, g, s, seed = None):
    '''
    Generate a random stabilizer tableau whose X-part is the Gram matrix, and Z-part is identity. The Gram matrix has rank <= g. 
    Args:
        n (int): number of qubits
        g (int): number of rows
        s (galois.FieldArray): secret vector
        seed (int | np.random.Generator): seed for random sampling
    Return:
        A random stabilizer tableau. 
    '''
    rng = wrap_seed(seed)
    G = random_gram(n, g, s, seed = rng)
    x = GF.Random((n, 1), seed = rng)
    r = G @ x # to ensure that the overlap is not zero.
    stab_tab = np.hstack((G, GF.Identity(n), r))
    return stab_tab


def add_row_redundancy(H, s, size, seed = None):
    '''
    Given the main part and secret, append redundant rows (number of rows given by size).
    '''
    H_R = []
    n = H.shape[1]
    rng = wrap_seed(seed)
    while len(H_R) < size:
        row = GF.Random(n, seed = rng)
        if np.dot(row, s) == 0 and np.any(row != 0):
            H_R.append(row)
    return np.append(H, H_R, axis = 0)


def add_col_redundancy(H_M, s, size, seed = None):
    '''
    Given the main part and the secret, append random codewords to the columns of H_M. 
    Return:
        Tuple(H_M, s)
    '''
    ext_col = []
    n = H_M.shape[1]
    rng = wrap_seed(seed)
    while len(ext_col) < size:
        x = GF.Random((n, 1), seed = rng)
        codeword = H_M @ x # random linear combination of cols in H_M
        ext_col.append(codeword)
    new_H_M = np.hstack((H_M, *ext_col)) # append random cols to the right of H_M
    new_s = np.append(s, GF.Zeros(size))
    return new_H_M, new_s




# %%
class Factorization:
    def __init__(self, tab, s = None):
        '''
        Given a stabilizer tableau, return a factorization of the Gram matrix satisfying the weight and codeword constraints.
        '''
        self.tab = tab #.astype(int).view(GF)
        self.s = s
        self.n = len(self.tab)
        G = tab[:, 0:self.n]
        assert np.all(G == G.T), "G must be symmetric"
        self.G = G #.astype(int).view(GF)
        self.rng = default_rng()

    def get_weight(self):
        '''
        Get weight constraint from the stabilizer tableau.
        '''
        weight_dict = {"00": 0, "01": 1, "10": 2, "11": 3}
        weights = []
        r = self.tab[:, 2*self.n]
        for i in range(self.n):
            weight = f"{r[i]}" + f"{self.G[i, i]}"
            weights.append(weight_dict[weight])
        return np.array(weights)
        
    def init_factor(self):
        '''
        Construct the initial factorization, based on [Lempel 75]. 
        '''
        row_sum = np.sum(self.G, axis = 1)
        N1 = np.nonzero(row_sum)[0] # idx for odd-parity rows

        E = GF.Zeros((len(N1), self.n))
        for i in range(len(N1)):
            E[i, N1[i]] = 1 # part corresponding to N1
        
        for i in range(self.n): # part corresponding to N2
            for j in range(i+1, self.n):
                if self.G[i, j] == 1:
                    tmp = GF.Zeros((1, self.n))
                    tmp[0, [i, j]] = 1, 1
                    E = np.append(E, tmp, axis = 0)
        return E

    def satisfy_weight_constraint(self, E):
        '''
        Make the factor satisfy the weight constraint. 
        '''
        weights = np.sum(E.view(np.ndarray), axis = 0) % 4 # weights of columns of E mod 4
        weight_diff = (self.get_weight() - weights) % 4
        for idx, w in enumerate(weight_diff):
            if w == 0:
                continue
            rows = GF.Zeros((w, self.n))
            rows[:, idx] = GF.Ones(w)
            E = np.append(E, rows, axis = 0)
        return E
    
    def self_consistent_eqn(self, one_sol = False):
        '''
        Generte solutions of self-consistent equation G.s = (|c_1|, ..., |c_n|)^T. 
        If one_sol = True, output a random vector from the solution space
        '''
        w = GF([self.G[i, i] for i in range(self.n)])
        candidate = solvesystem(self.G, w, all_sol=True) # solutions of G.s = w
        if one_sol == True:
            idx = self.rng.choice(len(candidate))
            return candidate[idx]
        else:
            return candidate

    def injecting_ones(self, E, s = None):
        '''
        Injection subroutine to inject the all-one codeword.
        '''
        if s is None:
            s = self.self_consistent_eqn(one_sol=True) 
            self.s = s
        indicator = E @ s.reshape(-1, 1) # indicator to separate two parts
        F = E[indicator.nonzero()[0]] # F.s = 1
        Z = E[np.where(indicator == 0)[0]] # Z.s = 0
        if len(Z) % 2 != 0:
            zeros = GF.Zeros((1, self.n))
            Z = np.append(Z, zeros, axis = 0)
        x = GF.Zeros(self.n)
        flip_idx = self.rng.choice(s.nonzero()[0]) # only a special case
        x[flip_idx] = 1
        ones = GF.Ones((len(Z), 1))
        Z = Z + ones @ x.reshape(1, -1)
        return np.append(F, Z, axis = 0)


    def final_factor(self):
        '''
        Combine the subroutines to generate the final factorization.
        '''
        E_init = self.init_factor()
        E = self.satisfy_weight_constraint(E_init)
        H = self.injecting_ones(E, self.s)
        H = self.satisfy_weight_constraint(H)
        return H



# %%
class QRCConstruction:
    def __init__(self, q):
        assert (q+1)%8 == 0, "(q + 1) must divide 8"
        self.q = q # size parameter
        self.n = int((q+3)/2) # num of qubits
        self.s = np.append([1], GF.Zeros(self.n - 1)) # initial secret
        self.P_s = self.init_main() # initial main part

    def quad_res(self):
        '''
        Generate the list of quadratic residues modulo 1.
        '''
        QRs = []
        for m in range(self.q):
            QRs.append(m**2% self.q)
        QRs.pop(0)
        return list(set(QRs))

    def init_main(self):
        '''
        Generate initial main part
        '''
        P_s = GF.Zeros((self.q, self.n))
        P_s[:, 0] = 1
        QRs = self.quad_res() # the list of quadratic residues
        for col in range(self.n-1):
            for qr in QRs:
                P_s[(qr - 1 + col)%self.q, col+1] = 1
        return P_s

    def ColAdd(self, i, j):
        '''
        Add the j-th column of P_s to the i-th column, and add the i-th element of s to the j-th element.
        '''
        s_i = self.s[i]
        s_j = self.s[j]
        s_j = s_i + s_j
        self.s[j] = s_j

        P_i = self.P_s[:, i]
        P_j = self.P_s[:, j]
        P_i = P_i + P_j
        self.P_s[:, i] = P_i


    def obfuscation(self, times, seed = None):
        '''
        Do column operations on P_s and s.
        '''
        rng = wrap_seed(seed)
        for _ in range(times):
            i, j = rng.choice(self.n, size = 2, replace = False)
            self.ColAdd(i, j)





